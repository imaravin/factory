package internal

import (
	"bytes"
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"os/exec"
	"regexp"
	"strings"
)

// CheckGHCLI checks if gh CLI is installed and authenticated
func CheckGHCLI() bool {
	cmd := exec.Command("gh", "auth", "status")
	err := cmd.Run()
	return err == nil
}

// CreatePRWithGH creates a PR using gh CLI
func CreatePRWithGH(repoPath, title, body, base string) (string, error) {
	cmd := exec.Command("gh", "pr", "create",
		"--title", title,
		"--body", body,
		"--base", base,
	)
	cmd.Dir = repoPath

	output, err := cmd.CombinedOutput()
	outStr := strings.TrimSpace(string(output))

	if err != nil {
		// Check if PR already exists
		if strings.Contains(outStr, "already exists") {
			return FindPRWithGH(repoPath)
		}
		return "", fmt.Errorf("gh pr create failed: %s", outStr)
	}

	// Extract URL from output
	re := regexp.MustCompile(`https://github\.com/[^\s]+`)
	if match := re.FindString(outStr); match != "" {
		return match, nil
	}

	return outStr, nil
}

// FindPRWithGH finds existing PR using gh CLI
func FindPRWithGH(repoPath string) (string, error) {
	cmd := exec.Command("gh", "pr", "view", "--json", "url", "-q", ".url")
	cmd.Dir = repoPath

	output, err := cmd.Output()
	if err != nil {
		return "", fmt.Errorf("no existing PR found")
	}

	return strings.TrimSpace(string(output)), nil
}

// CreatePR creates a PR - uses gh CLI if available, otherwise REST API
func CreatePR(cfg *Config, title, body, head, base string) (string, error) {
	// Try gh CLI first if no token provided or gh is available
	if cfg.GitHub.UseGHCLI && CheckGHCLI() {
		git := NewGit(cfg)
		return CreatePRWithGH(git.repoPath, title, body, base)
	}

	// Fall back to REST API
	return CreatePRWithAPI(cfg, title, body, head, base)
}

// CreatePRWithAPI creates a PR using GitHub REST API
func CreatePRWithAPI(cfg *Config, title, body, head, base string) (string, error) {
	url := fmt.Sprintf("https://api.github.com/repos/%s/%s/pulls", cfg.GitHub.Owner, cfg.GitHub.Repo)

	reqBody, _ := json.Marshal(map[string]string{
		"title": title,
		"body":  body,
		"head":  head,
		"base":  base,
	})

	req, _ := http.NewRequest("POST", url, bytes.NewReader(reqBody))
	req.Header.Set("Authorization", "Bearer "+cfg.GitHub.Token)
	req.Header.Set("Accept", "application/vnd.github+json")
	req.Header.Set("Content-Type", "application/json")

	resp, err := http.DefaultClient.Do(req)
	if err != nil {
		return "", err
	}
	defer resp.Body.Close()

	respBody, _ := io.ReadAll(resp.Body)

	// If PR exists, find it
	if resp.StatusCode == 422 {
		return FindExistingPR(cfg, head)
	}

	if resp.StatusCode >= 400 {
		return "", fmt.Errorf("github API error %d: %s", resp.StatusCode, string(respBody))
	}

	var result struct {
		HTMLURL string `json:"html_url"`
	}
	json.Unmarshal(respBody, &result)

	return result.HTMLURL, nil
}

func FindExistingPR(cfg *Config, head string) (string, error) {
	url := fmt.Sprintf("https://api.github.com/repos/%s/%s/pulls?head=%s:%s&state=open",
		cfg.GitHub.Owner, cfg.GitHub.Repo, cfg.GitHub.Owner, head)

	req, _ := http.NewRequest("GET", url, nil)
	req.Header.Set("Authorization", "Bearer "+cfg.GitHub.Token)
	req.Header.Set("Accept", "application/vnd.github+json")

	resp, err := http.DefaultClient.Do(req)
	if err != nil {
		return "", err
	}
	defer resp.Body.Close()

	var prs []struct {
		HTMLURL string `json:"html_url"`
	}

	respBody, _ := io.ReadAll(resp.Body)
	json.Unmarshal(respBody, &prs)

	if len(prs) > 0 {
		return prs[0].HTMLURL, nil
	}

	return "", fmt.Errorf("PR not found")
}

func FormatPRBody(issue *Issue, jiraURL string) string {
	return fmt.Sprintf(`## Summary
- **Issue**: [%s](%s/browse/%s)
- **Type**: %s
- **Priority**: %s

## Description
%s

## Acceptance Criteria
%s

## Validation
- [ ] Code builds successfully
- [ ] Tests pass
- [ ] Acceptance criteria verified

## Jira
Closes %s

---
*Generated by factory*`,
		issue.Key, jiraURL, issue.Key,
		issue.Type, issue.Priority,
		issue.Description,
		issue.AcceptanceCriteria,
		issue.Key)
}
